<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BMS 신청곡 리스트</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.6.2/sql-wasm.js"></script>
    <style>
        body { font-family: 'Pretendard', sans-serif; padding: 10px; background-color: #f4f7f9; margin: 0; }
        .container { max-width: 1300px; margin: 0 auto; }
        h2 { text-align: center; color: #2c3e50; font-size: 1.2rem; margin: 15px 0; }
        
        .controls { 
            margin-bottom: 15px; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            gap: 10px; 
            position: sticky; 
            top: 0; 
            background: #f4f7f9; 
            padding: 10px 0; 
            z-index: 100; 
        }
        .search-row { display: flex; justify-content: center; gap: 8px; width: 100%; max-width: 600px; }
        #searchInput { flex: 1; padding: 12px 20px; border: 2px solid #ddd; border-radius: 25px; outline: none; font-size: 14px; }
        #lvFilter { width: 110px; padding: 10px 5px; border: 2px solid #ddd; border-radius: 15px; outline: none; background: white; font-size: 13px; }
        
        .db-row { font-size: 12px; color: #666; display: flex; align-items: center; gap: 10px; }
        #status { font-weight: bold; color: #4A90E2; }

        .table-wrapper { background: white; border-radius: 10px; box-shadow: 0 2px 15px rgba(0,0,0,0.05); overflow: hidden; }
        table { width: 100%; border-collapse: collapse; table-layout: fixed; }
        th { background-color: #4A90E2; color: white; padding: 12px 5px; text-align: left; font-size: 12px; }
        td { padding: 10px 5px; border-bottom: 1px solid #eee; font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        tr:hover { background-color: #f9fcff; }
        
        .center { text-align: center; }
        .lv-tag { display: inline-block; padding: 2px 4px; border-radius: 4px; font-weight: bold; font-size: 10px; min-width: 38px; text-align: center; background: #eee; }
        .badge { display: inline-block; padding: 2px 5px; border-radius: 4px; font-size: 9px; font-weight: bold; color: white; min-width: 20px; text-align: center; }
        .bg-satellite { background-color: #5cacee; }
        .bg-stella { background-color: #ff6b6b; }
        .bg-insane { background-color: #a040f0; }

        /* 클리어 램프 */
        .lamp { display: inline-block; padding: 2px 4px; border-radius: 3px; font-size: 9px; font-weight: 800; color: white; text-align: center; min-width: 48px; }
        .lamp-0 { background-color: #adb5bd; } 
        .lamp-1 { background-color: #e74c3c; } 
        .lamp-2 { background-color: #9b59b6; } 
        .lamp-3 { background-color: #2ecc71; } 
        .lamp-4 { background-color: #3498db; } 
        .lamp-5 { background-color: #495057; } 
        .lamp-6 { background-color: #f1c40f; color: #333; } 
        .lamp-7 { background-color: #ff85a2; } 

        .copyable { cursor: pointer; color: #222; font-weight: 600; }
        .artist-text { color: #888; font-size: 11px; }

        .col-no { width: 40px; }
        .col-lamp { width: 65px; }
        .col-table { width: 35px; }
        .col-lv { width: 48px; }
        .col-artist { width: 22%; }

        @media (max-width: 768px) { .col-artist { display: none; } td { font-size: 12px; } }
        #toast { visibility: hidden; min-width: 160px; background-color: rgba(0,0,0,0.8); color: #fff; text-align: center; border-radius: 20px; padding: 10px; position: fixed; z-index: 1000; left: 50%; bottom: 50px; transform: translateX(-50%); font-size: 12px; }
        #toast.show { visibility: visible; animation: fadein 0.5s, fadeout 0.5s 1.5s; }
        @keyframes fadein { from {bottom: 0; opacity: 0;} to {bottom: 50px; opacity: 1;} }
        @keyframes fadeout { from {bottom: 50px; opacity: 1;} to {bottom: 0; opacity: 0;} }
    </style>
</head>
<body>

<div class="container">
    <h2>김편집의 BMS 신청곡 리스트</h2>
    
    <div class="controls">
        <div class="search-row">
            <select id="lvFilter"><option value="all">전체 LV</option></select>
            <input type="text" id="searchInput" placeholder="곡 제목 또는 아티스트 검색...">
        </div>
        <div class="db-row">
            <span>스코어 데이터 (.db):</span>
            <input type="file" id="scoreFileInput" accept=".db">
            <span id="status">로딩 중...</span>
        </div>
    </div>

    <div class="table-wrapper">
        <table>
            <thead>
                <tr>
                    <th class="center col-no">#</th>
                    <th class="center col-lamp">CLEAR</th>
                    <th class="center col-table">Tbl</th>
                    <th class="center col-lv">LV</th>
                    <th class="col-title">TITLE (복사)</th>
                    <th class="col-artist">ARTIST</th>
                </tr>
            </thead>
            <tbody id="tableBody"></tbody>
        </table>
    </div>
</div>

<div id="toast">곡명이 복사되었습니다!</div>

<script>
    let songData = [];
    let titleToClearMap = new Map(); // 곡명 -> 클리어 상태
    const tableMap = { 'Satellite': 'sl', 'Stella': 'st', 'Insane': '★' };
    const lampNames = ["NO PLAY", "FAILED", "A-CLEAR", "E-CLEAR", "CLEAR", "H-CLEAR", "XH-CLEAR", "F-COMBO"];

    // 1. 테이블 파싱 (해시 없이 곡명만 추출)
    function parseTable(text, tableName) {
        if (tableName === 'Insane') {
            const regex = /\[\s*\d+\s*,\s*"(.*?)"\s*,\s*"(.*?)"\s*,\s*".*?"\s*,\s*"(.*?)"/g;
            let matches; const res = [];
            while ((matches = regex.exec(text)) !== null) {
                res.push({
                    table: tableName, displayTable: tableMap[tableName],
                    lv: matches[1].trim(), title: matches[2].trim(),
                    artist: matches[3].replace(/<\/?[^>]+(>|$)/g, "").trim()
                });
            }
            return res;
        } else {
            const parser = new DOMParser();
            const doc = parser.parseFromString(text, 'text/html');
            const rows = Array.from(doc.querySelectorAll('#table_int tr')).slice(2);
            return rows.map(row => {
                const tds = row.querySelectorAll('td');
                if (tds.length < 3 || row.classList.contains('tr_separate')) return null;
                return {
                    table: tableName, displayTable: tableMap[tableName],
                    lv: tds[0].innerText.trim(), title: tds[1].innerText.trim(),
                    artist: tds[2].innerText.trim()
                };
            }).filter(i => i !== null);
        }
    }

    // 2. DB 파일 로드 및 곡명 매핑
    document.getElementById('scoreFileInput').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function() {
            initSqlJs({ locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.6.2/sql-wasm.wasm` }).then(function(SQL) {
                const db = new SQL.Database(new Uint8Array(reader.result));
                
                try {
                    // music 테이블과 score 테이블을 JOIN하여 제목과 클리어 상태를 가져옵니다.
                    // (사용하시는 구동기/도구의 DB 스키마에 따라 테이블명이나 컬럼명이 다를 수 있습니다.)
                    const results = db.exec(`
                        SELECT music.title, score.clear 
                        FROM score 
                        JOIN music ON score.hash = music.hash
                    `);

                    if (results.length > 0) {
                        titleToClearMap.clear();
                        results[0].values.forEach(row => {
                            if (row[0]) {
                                // 곡명을 소문자로 변환하고 공백을 제거하여 매칭 확률을 높임
                                const normalizedTitle = row[0].toLowerCase().trim();
                                titleToClearMap.set(normalizedTitle, row[1]);
                            }
                        });
                        document.getElementById('status').innerText = `기록 반영 완료! (${titleToClearMap.size}곡)`;
                        renderTable(songData);
                    }
                } catch (err) {
                    // music 테이블이 없는 경우 scorehash만 있는 기본 구조일 수 있으므로 예외 처리
                    alert("DB 구조를 분석할 수 없습니다. 곡명 정보가 포함된 DB인지 확인해주세요.");
                    console.error(err);
                }
            });
        };
        reader.readAsArrayBuffer(file);
    });

    async function init() {
        try {
            const [resSat, resSte, resIns] = await Promise.all([
                fetch('Satellite.html').then(r => r.text()),
                fetch('Stella.html').then(r => r.text()),
                fetch('Insane.html').then(r => r.text())
            ]);

            const sat = parseTable(resSat, 'Satellite');
            const ste = parseTable(resSte, 'Stella');
            const ins = parseTable(resIns, 'Insane');

            let num = 1;
            songData = [...sat, ...ste, ...ins];
            songData.forEach(s => s.fixedNo = num++);

            populateLvFilter();
            renderTable(songData);
            document.getElementById('status').innerText = "score.db를 선택해주세요.";
        } catch (e) {
            document.getElementById('status').innerText = "데이터 로드 실패";
        }
    }

    function renderTable(data) {
        const body = document.getElementById('tableBody');
        body.innerHTML = data.map((s) => {
            const tClass = s.table === 'Stella' ? 'bg-stella' : (s.table === 'Insane' ? 'bg-insane' : 'bg-satellite');
            
            // 곡명 기반 매칭 (소문자/공백 제거 비교)
            const normalizedTitle = s.title.toLowerCase().trim();
            const clear = titleToClearMap.get(normalizedTitle) || 0;
            
            return `
                <tr>
                    <td class="center" style="color:#999;">${s.fixedNo}</td>
                    <td class="center"><span class="lamp lamp-${clear}">${lampNames[clear]}</span></td>
                    <td class="center"><span class="badge ${tClass}">${s.displayTable}</span></td>
                    <td class="center"><span class="lv-tag">${s.lv}</span></td>
                    <td class="copyable" onclick="copyToClipboard('${s.title.replace(/'/g, "\\'")}')">
                        <b>${s.title}</b>
                    </td>
                    <td class="artist-text">${s.artist}</td>
                </tr>
            `;
        }).join('');
    }

    // (populateLvFilter, copyToClipboard, update 등 나머지 함수는 이전과 동일)
    function populateLvFilter() {
        const filter = document.getElementById('lvFilter');
        const lvs = [...new Set(songData.map(s => s.lv))].sort((a, b) => {
            const getP = (v) => v.startsWith('sl') ? 1 : (v.startsWith('st') ? 2 : 3);
            if (getP(a) !== getP(b)) return getP(a) - getP(b);
            return (parseInt(a.replace(/[^0-9]/g, '')) || 0) - (parseInt(b.replace(/[^0-9]/g, '')) || 0);
        });
        lvs.forEach(l => {
            const opt = document.createElement('option');
            opt.value = l; opt.textContent = l; filter.appendChild(opt);
        });
    }

    function copyToClipboard(t) {
        const el = document.createElement('textarea');
        el.value = t; document.body.appendChild(el); el.select();
        document.execCommand('copy'); document.body.removeChild(el);
        const toast = document.getElementById("toast");
        toast.className = "show";
        setTimeout(() => { toast.className = ""; }, 2000);
    }

    function update() {
        const q = document.getElementById('searchInput').value.toLowerCase();
        const lv = document.getElementById('lvFilter').value;
        const filtered = songData.filter(s => {
            const mQ = s.title.toLowerCase().includes(q) || s.artist.toLowerCase().includes(q);
            const mLv = (lv === 'all' || s.lv === lv);
            return mQ && mLv;
        });
        renderTable(filtered);
    }

    document.getElementById('searchInput').addEventListener('keyup', update);
    document.getElementById('lvFilter').addEventListener('change', update);
    init();
</script>

</body>
</html>